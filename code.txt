#geo05.normalize.R
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("limma")


#引用包
library(limma)

inputFile="geneMatrix.txt"     #表达数据文件
conFile="s1.txt"               #对照组的样品信息文件
treatFile="s2.txt"             #实验组的样品信息文件
geoID="GSE5281"                #GEO数据库研究的id
setwd("C:\\ad\\05.normalize\\GSE7669")      #设置工作目录

#读取输入文件，并对输入文件整理
rt=read.table(inputFile, header=T, sep="\t", check.names=F)
rt=as.matrix(rt)
rownames(rt)=rt[,1]
exp=rt[,2:ncol(rt)]
dimnames=list(rownames(exp),colnames(exp))
data=matrix(as.numeric(as.matrix(exp)),nrow=nrow(exp),dimnames=dimnames)
rt=avereps(data)

#如果数据没有取log2, 会对数据自动取log2
qx=as.numeric(quantile(rt, c(0, 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC=( (qx[5]>100) || ( (qx[6]-qx[1])>50 && qx[2]>0) )
if(LogC){
	rt[rt<0]=0
	rt=log2(rt+1)}
data=normalizeBetweenArrays(rt)

#读取样品信息的文件(对照组和实验组)
sample1=read.table(conFile, header=F, sep="\t", check.names=F)
sample2=read.table(treatFile, header=F, sep="\t", check.names=F)
sampleName1=gsub("^ | $", "", as.vector(sample1[,1]))
sampleName2=gsub("^ | $", "", as.vector(sample2[,1]))
conData=data[,sampleName1]
treatData=data[,sampleName2]
data=cbind(conData,treatData)
conNum=ncol(conData)
treatNum=ncol(treatData)

#输出所有基因矫正后的表达量
Type=c(rep("Control",conNum),rep("Treat",treatNum))
outData=rbind(id=paste0(colnames(data),"_",Type),data)
write.table(outData,file=paste0(geoID,".normalize.txt"),sep="\t",quote=F,col.names=F)


##geo06.sva.R
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("limma")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("sva")


#引用包
library(limma)
library(sva)
setwd("C:\\ad\\06.sva")      #设置工作目录

#获取目录下所有"normalize.txt"结尾的文件
files=dir()
files=grep("normalize.txt$", files, value=T)
geneList=list()

#读取所有txt文件中的基因信息，保存到geneList
for(file in files){
	if(file=="merge.preNorm.txt"){next}
	if(file=="merge.normalize.txt"){next}
    rt=read.table(file, header=T, sep="\t", check.names=F)      #读取输入文件
    geneNames=as.vector(rt[,1])      #提取基因名称
    uniqGene=unique(geneNames)       #基因取unique
    header=unlist(strsplit(file, "\\.|\\-"))
    geneList[[header[1]]]=uniqGene
}

#获取交集基因
interGenes=Reduce(intersect, geneList)

#数据合并
allTab=data.frame()
batchType=c()
for(i in 1:length(files)){
    inputFile=files[i]
	if(inputFile=="merge.preNorm.txt"){next}
	if(inputFile=="merge.normalize.txt"){next}
    header=unlist(strsplit(inputFile, "\\.|\\-"))
    #读取输入文件，并对输入文件进行整理
    rt=read.table(inputFile, header=T, sep="\t", check.names=F)
    rt=as.matrix(rt)
    rownames(rt)=rt[,1]
    exp=rt[,2:ncol(rt)]
    dimnames=list(rownames(exp),colnames(exp))
    data=matrix(as.numeric(as.matrix(exp)),nrow=nrow(exp),dimnames=dimnames)
    rt=avereps(data)
    colnames(rt)=paste0(header[1], "_", colnames(rt))

    #数据合并
    if(i==1){
    	allTab=rt[interGenes,]
    }else{
    	allTab=cbind(allTab, rt[interGenes,])
    }
    batchType=c(batchType, rep(i,ncol(rt)))
}

#输出合并后的表达数据
outTab=rbind(geneNames=colnames(allTab), allTab)
write.table(outTab, file="merge.preNorm.txt", sep="\t", quote=F, col.names=F)

#对合并后数据进行批次矫正，输出批次矫正后的表达数据
outTab=ComBat(allTab, batchType, par.prior=TRUE)
outTab=rbind(geneNames=colnames(outTab), outTab)
write.table(outTab, file="merge.normalize.txt", sep="\t", quote=F, col.names=F)

##geo07.boxplot.R
#install.packages("reshape2")
#install.packages("ggplot2")


#引用包
library(reshape2)
library(ggplot2)

setwd("C:\\ad\\07.boxplot")     #设置工作目录

#定义箱线图的函数
bioBoxplot=function(inputFile=null, outFile=null, titleName=null){
	#读取输入文件,提取数据
	rt=read.table(inputFile, header=T, sep="\t", check.names=F, row.names=1)
	data=t(rt)
	Project=gsub("(.*?)\\_.*", "\\1", rownames(data))            #获取数据研究的id
	Sample=gsub("(.+)\\_(.+)\\_(.+)", "\\2", rownames(data))     #获取样品的名称
	data=cbind(as.data.frame(data), Sample, Project)
	
	#把数据转换成ggplot2输入文件
	rt1=melt(data, id.vars=c("Project", "Sample"))
	colnames(rt1)=c("Project","Sample","Gene","Expression")

	#绘制箱线图
	pdf(file=outFile, width=10, height=5)
	p=ggplot(rt1, mapping=aes(x=Sample, y=Expression))+
  		geom_boxplot(aes(fill=Project), notch=T, outlier.shape=NA)+
  		ggtitle(titleName)+ theme_bw()+ theme(panel.grid=element_blank())+ 
  		theme(axis.text.x=element_text(angle=45,vjust=0.5,hjust=0.5,size=2), plot.title=element_text(hjust = 0.5))
	print(p)
	dev.off()
}

#调用函数, 绘制批次矫正前的箱线图
bioBoxplot(inputFile="merge.preNorm.txt", outFile="boxplot.preNorm.pdf", titleName="Before batch correction")
#调用函数, 绘制批次矫正后的箱线图
bioBoxplot(inputFile="merge.normalize.txt", outFile="boxplot.normalzie.pdf", titleName="After batch correction")





##geo08.PCA.R

#install.packages("ggplot2")
#install.packages("ggpubr")


#引用包
library(ggplot2)
library(ggpubr)
setwd("C:\\ad\\08.PCA")    #设置工作目录

#定义PCA分析的函数
bioPCA=function(inputFile=null, outFile=null, titleName=null){
	#读取输入文件,提取数据
	rt=read.table(inputFile, header=T, sep="\t", check.names=F, row.names=1)
	data=t(rt)
	Project=gsub("(.*?)\\_.*", "\\1", rownames(data))    #获取GEO数据库研究的id
	
	#PCA分析
	data.pca=prcomp(data)
	pcaPredict=predict(data.pca)
	PCA=data.frame(PC1=pcaPredict[,1], PC2=pcaPredict[,2], Type=Project)

	#绘制PCA的图形
	pdf(file=outFile, width=5.5, height=4.25)
	p1=ggscatter(data=PCA, x="PC1", y="PC2", color="Type", shape="Type", 
	          ellipse=T, ellipse.type="norm", ellipse.border.remove=F, ellipse.alpha = 0.1,
	          size=2, main=titleName, legend="right")+
	          theme(plot.margin=unit(rep(1.5,4),'lines'), plot.title = element_text(hjust=0.5))
	print(p1)
	dev.off()
}

#调用函数, 绘制批次矫正前的图形
bioPCA(inputFile="merge.preNorm.txt", outFile="PCA.preNorm.pdf", titleName="Before batch correction")
#调用函数, 绘制批次矫正后的图形
bioPCA(inputFile="merge.normalize.txt", outFile="PCA.normalzie.pdf", titleName="After batch correction")





##geo09.diff.R
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("limma")

#install.packages("pheatmap")
#install.packages("ggplot2")


#引用包
library(limma)
library(dplyr)
library(pheatmap)
library(ggplot2)

logFCfilter=0.585           #logFC的过滤条件(logFC=0.585,差异倍数1.5倍;logFC=1,差异2倍;logFC=2,差异4倍)
adj.P.Val.Filter=0.05      #矫正后p值的过滤条件
inputFile="merge.normalize.txt"      #表达数据文件
diseaseName="Rheumatoid arthritis"                  #设置图形中展示疾病的名称
setwd("C:\\ad\\09.diff")      #设置工作目录

#读取输入文件，并对输入文件整理
rt=read.table(inputFile, header=T, sep="\t", check.names=F)
rt=as.matrix(rt)
rownames(rt)=rt[,1]
exp=rt[,2:ncol(rt)]
dimnames=list(rownames(exp),colnames(exp))
data=matrix(as.numeric(as.matrix(exp)),nrow=nrow(exp),dimnames=dimnames)
data=avereps(data)

#获取样品的分组信息
Type=gsub("(.*)\\_(.*)\\_(.*)", "\\3", colnames(data))
data=data[,order(Type)]       #根据样品的分组信息对样品进行排序
Project=gsub("(.+)\\_(.+)\\_(.+)", "\\1", colnames(data))    #获得GEO数据研究的id
Type=gsub("(.*)\\_(.*)\\_(.*)", "\\3", colnames(data))
colnames(data)=gsub("(.+)\\_(.+)\\_(.+)", "\\2", colnames(data))

#差异分析
design <- model.matrix(~0+factor(Type))
colnames(design) <- c("Control","Treat")
fit <- lmFit(data,design)
cont.matrix<-makeContrasts(Treat-Control,levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)

#输出所有基因的差异情况
allDiff=topTable(fit2,adjust='fdr',number=200000)
allDiffOut=rbind(id=colnames(allDiff),allDiff)
write.table(allDiffOut, file="all.txt", sep="\t", quote=F, col.names=F)

#输出显著的差异基因
diffSig=allDiff[with(allDiff, (abs(logFC)>logFCfilter & adj.P.Val < adj.P.Val.Filter )), ]
diffSigOut=rbind(id=colnames(diffSig),diffSig)
write.table(diffSigOut, file="diff.txt", sep="\t", quote=F, col.names=F)

#输出差异基因表达量
diffGeneExp=data[row.names(diffSig),]
diffGeneExpOut=rbind(id=paste0(colnames(diffGeneExp),"_",Type), diffGeneExp)
write.table(diffGeneExpOut, file="diffGeneExp.txt", sep="\t", quote=F, col.names=F)

#绘制差异基因热图
geneNum=50     #定义展示基因的数目
diffUp=diffSig[diffSig$logFC>0,]
diffDown=diffSig[diffSig$logFC<0,]
geneUp=row.names(diffUp)
geneDown=row.names(diffDown)
if(nrow(diffUp)>geneNum){geneUp=row.names(diffUp)[1:geneNum]}
if(nrow(diffDown)>geneNum){geneDown=row.names(diffDown)[1:geneNum]}
hmExp=data[c(geneUp,geneDown),]
#准备注释文件
Type=ifelse(Type=="Control", "Control", diseaseName)
Type=factor(Type, levels=c("Control", diseaseName))
names(Type)=colnames(data)
Type=as.data.frame(Type)
Type=cbind(Project, Type)
#输出图形
pdf(file="heatmap.pdf", width=10, height=7)
pheatmap(hmExp, 
         annotation_col=Type, 
         color = colorRampPalette(c("blue2", "white", "red2"))(50),
         cluster_cols =F,
         show_colnames = F,
         scale="row",
         fontsize = 8,
         fontsize_row=5.5,
         fontsize_col=8)
dev.off()


#定义显著性
rt=read.table("all.txt", header=T, sep="\t", check.names=F)
Sig=ifelse((rt$adj.P.Val<adj.P.Val.Filter) & (abs(rt$logFC)>logFCfilter), ifelse(rt$logFC>logFCfilter,"Up","Down"), "Not")
#绘制火山图
rt = mutate(rt, Sig=Sig)
p = ggplot(rt, aes(logFC, -log10(adj.P.Val)))+
    geom_point(aes(col=Sig))+
    scale_color_manual(values=c("green2", "grey","red2"))+
    labs(title = " ")+ theme_bw()+ 
    theme(plot.title = element_text(size=16, hjust=0.5, face = "bold"))
#输出图形
pdf(file="vol.pdf", width=5.5, height=4.5)
print(p)
dev.off()




###geo10.WGCNA.R

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(c("GO.db", "preprocessCore", "impute", "limma"))

#install.packages(c("matrixStats", "Hmisc", "foreach", "doParallel", "fastcluster", "dynamicTreeCut", "survival")) 
#install.packages("WGCNA")


#引用包
library(limma)
library(WGCNA)

expFile="merge.normalize.txt"      #表达数据文件
diseaseName="Disease"                #设置图形中展示疾病的名称
setwd("C:\\biowolf\\smrML\\10.WGCNA")     #设置工作目录

#读取输入文件，并对输入文件整理
rt=read.table(expFile, header=T, sep="\t", check.names=F)
rt=as.matrix(rt)
rownames(rt)=rt[,1]
exp=rt[,2:ncol(rt)]
dimnames=list(rownames(exp),colnames(exp))
data=matrix(as.numeric(as.matrix(exp)),nrow=nrow(exp),dimnames=dimnames)
data=avereps(data)
data=data[apply(data,1,sd)>0.5,]     #去除波动小的基因

#提取样品的分组信息(对照组和实验组)
Type=gsub("(.*)\\_(.*)\\_(.*)", "\\3", colnames(data))
data=data[,order(Type)]
Type=gsub("(.*)\\_(.*)\\_(.*)", "\\3", colnames(data))
conCount=length(Type[Type=="Control"])
treatCount=length(Type[Type=="Treat"])
datExpr0=t(data)

###检查缺失值
gsg = goodSamplesGenes(datExpr0, verbose = 3)
if (!gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0)
    printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")))
  if (sum(!gsg$goodSamples)>0)
    printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")))
  # Remove the offending genes and samples from the data:
  datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}

###样品聚类
sampleTree = hclust(dist(datExpr0), method = "average")
pdf(file = "1_sample_cluster.pdf", width = 9, height = 6)
par(cex = 0.6)
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
###剪切线
abline(h = 20000, col = "red")
dev.off()

###删除剪切线以下的样品
clust = cutreeStatic(sampleTree, cutHeight=20000, minSize=10)
table(clust)
keepSamples = (clust==1)
datExpr0 = datExpr0[keepSamples, ]


###准备样品的临床数据
traitData=data.frame(Control=c(rep(1,conCount),rep(0,treatCount)),
                     Treat=c(rep(0,conCount),rep(1,treatCount)))
colnames(traitData)=c("Control", diseaseName)
row.names(traitData)=colnames(data)
fpkmSamples = rownames(datExpr0)
traitSamples =rownames(traitData)
sameSample=intersect(fpkmSamples,traitSamples)
datExpr0=datExpr0[sameSample,]
datTraits=traitData[sameSample,]


###再次对样品进行聚类,得到样品聚类的热图
sampleTree2 = hclust(dist(datExpr0), method = "average")
traitColors = numbers2colors(datTraits, signed = FALSE)
pdf(file="2_sample_heatmap.pdf", width=9, height=7)
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits),
                    main = "Sample dendrogram and trait heatmap")
dev.off()

###power值的散点图
enableWGCNAThreads()   #多线程工作
powers = c(1:20)       #幂指数范围1:20
sft = pickSoftThreshold(datExpr0, powerVector = powers, verbose = 5)
pdf(file="3_scale_independence.pdf", width=9, height=5)
par(mfrow = c(1,2))
cex1 = 0.9
###拟合指数与power值散点图
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
abline(h=0.8, col="red") #可以修改
###平均连通性与power值散点图
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
dev.off()

###邻接矩阵转换
sft      #查看最佳power值
softPower =sft$powerEstimate      #最佳power值
adjacency = adjacency(datExpr0, power = softPower)
softPower

###TOM距离矩阵
TOM = TOMsimilarity(adjacency)
dissTOM = 1-TOM

###基因聚类
geneTree = hclust(as.dist(dissTOM), method = "average");
pdf(file="4_gene_clustering.pdf", width=8, height=6)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)
dev.off()


###动态的模块识别(得到每个基因属于哪个模块)
minModuleSize = 60      #模块基因数目(每个模块至少包含60个基因)
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize);
table(dynamicMods)
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
pdf(file="5_Dynamic_Tree.pdf", width=8, height=6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
dev.off()


###对模块进行聚类,找出相似模块聚类
MEList = moduleEigengenes(datExpr0, colors = dynamicColors)
MEs = MEList$eigengenes
MEDiss = 1-cor(MEs);
METree = hclust(as.dist(MEDiss), method = "average")
pdf(file="6_Clustering_module.pdf", width=7, height=6)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")
MEDissThres = 0.25     #剪切高度可修改
abline(h=MEDissThres, col = "red")
dev.off()


###相似模块合并(得到最终的每个基因所属的模块)
merge = mergeCloseModules(datExpr0, dynamicColors, cutHeight = MEDissThres, verbose = 3)
mergedColors = merge$colors
mergedMEs = merge$newMEs
pdf(file="7_merged_dynamic.pdf", width=8, height=6)
plotDendroAndColors(geneTree, mergedColors, "Merged dynamic",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
dev.off()
moduleColors = mergedColors
table(moduleColors)
colorOrder = c("grey", standardColors(50))
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs


###绘制模块与临床性状相关性的热图
nGenes = ncol(datExpr0)
nSamples = nrow(datExpr0)
moduleTraitCor = cor(MEs, datTraits, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
pdf(file="8_Module_trait.pdf", width=5.5, height=5.5)
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(5, 10, 3, 3))
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),    #X轴的标签
               yLabels = names(MEs),          #Y轴的标签
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),    #图形的颜色
               textMatrix = textMatrix,      #图形展示的文本信息
               setStdMargins = FALSE,
               cex.text = 0.75,          #字体的大小
               zlim = c(-1,1),           #相关系数的范围
               main = paste("Module-trait relationships"))     #图形的标题
dev.off()

###输出模块重要性的图形
y=datTraits[,1]
GS1=as.numeric(cor(y, datExpr0, use="p"))
GeneSignificance=abs(GS1)
ModuleSignificance=tapply(GeneSignificance, mergedColors, mean, na.rm=T)
pdf(file="9_GeneSignificance.pdf", width=12.5, height=7.5)
plotModuleSignificance(GeneSignificance, mergedColors)
dev.off()

###输出每个模块的基因
for (mod in 1:nrow(table(moduleColors))){  
	modules = names(table(moduleColors))[mod]
	probes = colnames(datExpr0)
	inModule = (moduleColors == modules)
	modGenes = probes[inModule]
	write.table(modGenes, file =paste0("module_",modules,".txt"),sep="\t",row.names=F,col.names=F,quote=F)
}

##geo11.venn.R
#install.packages("ggvenn")


#引用包
library(ggvenn)

diffFile="diff.txt"                   #差异分析的结果文件
moduleFile="module_green.txt"       #模块基因的文件
setwd("C:\\ad\\11.venn")     #设置工作目录
geneList=list()

#读取差异分析的结果文件
rt=read.table("diff.txt", header=T, sep="\t", check.names=F)
geneNames=as.vector(rt[,1])               #提取差异基因的名称
geneNames=gsub("^ | $","",geneNames)     #去掉基因首尾的空格
uniqGene=unique(geneNames)                #对差异基因取unique
geneList[["DEG"]]=uniqGene

#读取模块基因的文件
rt=read.table(moduleFile, header=F, sep="\t", check.names=F)
geneNames=as.vector(rt[,1])                #提取模块基因的名称
geneNames=gsub("^ | $","",geneNames)     #去掉基因首尾的空格
uniqGene=unique(geneNames)                 #对模块基因取unique
geneList[["WGCNA"]]=uniqGene

#绘制venn图
pdf(file="venn.pdf", width=6, height=6)
ggvenn(geneList,show_percentage = T,
	stroke_color = "white", stroke_size = 0.5,
	fill_color = c("#E41A1C","#1E90FF"),
	set_name_color =c("#E41A1C","#1E90FF"),
	set_name_size=6, text_size=4.5)
dev.off()

#输出交集基因
interGenes=Reduce(intersect, geneList)
write.table(file="interGenes.txt", interGenes, sep="\t", quote=F, col.names=F, row.names=F)




##geo12.GO.R
#install.packages("colorspace")
#install.packages("stringi")
#install.packages("ggplot2")
#install.packages("circlize")
#install.packages("RColorBrewer")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("org.Hs.eg.db")
#BiocManager::install("DOSE")
#BiocManager::install("clusterProfiler")
#BiocManager::install("enrichplot")
#BiocManager::install("ComplexHeatmap")


#引用包
library(clusterProfiler)
library(org.Hs.eg.db)
library(enrichplot)
library(ggplot2)
library(circlize)
library(RColorBrewer)
library(dplyr)
library(ComplexHeatmap)

pvalueFilter=0.05       #p值的过滤条件
adjPvalFilter=1         #矫正后p值的过滤条件

#定义图形的颜色
colorSel="p.adjust"
if(adjPvalFilter>0.05){
	colorSel="pvalue"
}

setwd("C:\\ad\\12.GO")      #设置工作目录
rt=read.table("interGenes.txt", header=F, sep="\t", check.names=F)     #读取交集基因的列表文件

#提取基因的名称, 将基因名称转换为基因id
genes=unique(as.vector(rt[,1]))
entrezIDs=mget(genes, org.Hs.egSYMBOL2EG, ifnotfound=NA)
entrezIDs=as.character(entrezIDs)
rt=cbind(rt, entrezIDs)
rt=rt[rt[,"entrezIDs"]!="NA",]      #去除基因id为NA的基因
gene=rt$entrezID
#gene=gsub("c\\(\"(\\d+)\".*", "\\1", gene)

#GO富集分析
kk=enrichGO(gene=gene, OrgDb=org.Hs.eg.db, pvalueCutoff=1, qvalueCutoff=1, ont="all", readable=T)
GO=as.data.frame(kk)
GO=GO[(GO$pvalue<pvalueFilter & GO$p.adjust<adjPvalFilter),]
#输出显著富集分析的结果
write.table(GO, file="GO.txt", sep="\t", quote=F, row.names = F)

#柱状图
pdf(file="barplot.pdf", width=8, height=7)
bar=barplot(kk, drop=TRUE, showCategory=10, label_format=100, split="ONTOLOGY", color=colorSel) + facet_grid(ONTOLOGY~., scale='free')
print(bar)
dev.off()
		
#气泡图
pdf(file="bubble.pdf", width=8, height=7)
bub=dotplot(kk, showCategory=10, orderBy="GeneRatio", label_format=100, split="ONTOLOGY", color=colorSel) + facet_grid(ONTOLOGY~., scale='free')
print(bub)
dev.off()


###########绘制GO圈图###########
ontology.col=c("#5C88DAFF", "#CE3D32FF", "#00AF66FF")
data=GO[order(GO$pvalue),]
datasig=data[data$pvalue<0.05,,drop=F]
BP = datasig[datasig$ONTOLOGY=="BP",,drop=F]
CC = datasig[datasig$ONTOLOGY=="CC",,drop=F]
MF = datasig[datasig$ONTOLOGY=="MF",,drop=F]
BP = head(BP,6)
CC = head(CC,6)
MF = head(MF,6)
data = rbind(BP,CC,MF)
main.col = ontology.col[as.numeric(as.factor(data$ONTOLOGY))]

#整理圈图数据
BgGene = as.numeric(sapply(strsplit(data$BgRatio,"/"),'[',1))
Gene = as.numeric(sapply(strsplit(data$GeneRatio,'/'),'[',1))
ratio = Gene/BgGene
logpvalue = -log(data$pvalue,10)
logpvalue.col = brewer.pal(n = 6, name = "Reds")
f = colorRamp2(breaks = c(0,2,4,6,8,10), colors = logpvalue.col)
BgGene.col = f(logpvalue)
df = data.frame(GO=data$ID,start=1,end=max(BgGene))
rownames(df) = df$GO
bed2 = data.frame(GO=data$ID,start=1,end=BgGene,BgGene=BgGene,BgGene.col=BgGene.col)
bed3 = data.frame(GO=data$ID,start=1,end=Gene,BgGene=Gene)
bed4 = data.frame(GO=data$ID,start=1,end=max(BgGene),ratio=ratio,col=main.col)
bed4$ratio = bed4$ratio/max(bed4$ratio)*9.5

#绘制圈图主体部分
pdf(file="GO.circlize.pdf", width=10, height=10)
par(omi=c(0.1,0.1,0.1,1.5))
circos.par(track.margin=c(0.01,0.01))
circos.genomicInitialize(df,plotType="none")
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
  sector.index = get.cell.meta.data("sector.index")
  xlim = get.cell.meta.data("xlim")
  ylim = get.cell.meta.data("ylim")
  circos.text(mean(xlim), mean(ylim), sector.index, cex = 0.8, facing = "bending.inside", niceFacing = TRUE)
}, track.height = 0.08, bg.border = NA,bg.col = main.col)

for(si in get.all.sector.index()) {
  circos.axis(h = "top", labels.cex = 0.6, sector.index = si,track.index = 1,
              major.at=seq(0,max(BgGene),by=100),labels.facing = "clockwise")
}
f = colorRamp2(breaks = c(-1, 0, 1), colors = c("green", "black", "red"))
circos.genomicTrack(bed2, ylim = c(0, 1),track.height = 0.1,bg.border="white",
                    panel.fun = function(region, value, ...) {
                      i = getI(...)
                      circos.genomicRect(region, value, ytop = 0, ybottom = 1, col = value[,2], 
                                         border = NA, ...)
                      circos.genomicText(region, value, y = 0.4, labels = value[,1], adj=0,cex=0.8,...)
                    })
circos.genomicTrack(bed3, ylim = c(0, 1),track.height = 0.1,bg.border="white",
                    panel.fun = function(region, value, ...) {
                      i = getI(...)
                      circos.genomicRect(region, value, ytop = 0, ybottom = 1, col = '#BA55D3', 
                                         border = NA, ...)
                      circos.genomicText(region, value, y = 0.4, labels = value[,1], cex=0.9,adj=0,...)
                    })
circos.genomicTrack(bed4, ylim = c(0, 10),track.height = 0.35,bg.border="white",bg.col="grey90",
                    panel.fun = function(region, value, ...) {
                      cell.xlim = get.cell.meta.data("cell.xlim")
                      cell.ylim = get.cell.meta.data("cell.ylim")
                      for(j in 1:9) {
                        y = cell.ylim[1] + (cell.ylim[2]-cell.ylim[1])/10*j
                        circos.lines(cell.xlim, c(y, y), col = "#FFFFFF", lwd = 0.3)
                      }
                      circos.genomicRect(region, value, ytop = 0, ybottom = value[,1], col = value[,2], 
                                         border = NA, ...)
                      #circos.genomicText(region, value, y = 0.3, labels = value[,1], ...)
                    })
circos.clear()
#绘制圈图中间的图例
middle.legend = Legend(
  labels = c('Number of Genes','Number of Select','Rich Factor(0-1)'),
  type="points",pch=c(15,15,17),legend_gp = gpar(col=c('pink','#BA55D3',ontology.col[1])),
  title="",nrow=3,size= unit(3, "mm")
)
circle_size = unit(1, "snpc")
draw(middle.legend,x=circle_size*0.42)
#绘制GO分类的图例
main.legend = Legend(
  labels = c("Biological Process", "Cellular Component", "Molecular Function"),  type="points",pch=15,
  legend_gp = gpar(col=ontology.col), title_position = "topcenter",
  title = "ONTOLOGY", nrow = 3,size = unit(3, "mm"),grid_height = unit(5, "mm"),
  grid_width = unit(5, "mm")
)
#富集显著性pvalue的图例
logp.legend = Legend(
  labels=c('(0,2]','(2,4]','(4,6]','(6,8]','(8,10]','>=10'),
  type="points",pch=16,legend_gp=gpar(col=logpvalue.col),title="-log10(Pvalue)",
  title_position = "topcenter",grid_height = unit(5, "mm"),grid_width = unit(5, "mm"),
  size = unit(3, "mm")
)
lgd = packLegend(main.legend,logp.legend)
circle_size = unit(1, "snpc")
print(circle_size)
draw(lgd, x = circle_size*0.85, y=circle_size*0.55,just = "left")
dev.off()



##geo13.KEGG.R
#install.packages("colorspace")
#install.packages("stringi")
#install.packages("ggplot2")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("org.Hs.eg.db")
#BiocManager::install("DOSE")
#BiocManager::install("clusterProfiler")
#BiocManager::install("enrichplot")


#引用包
library("clusterProfiler")
library("org.Hs.eg.db")
library("enrichplot")
library("ggplot2")

pvalueFilter=0.05      #p值过滤条件
adjPvalFilter=1         #矫正后的p值过滤条件

#定义图形的颜色
colorSel="p.adjust"
if(adjPvalFilter>0.05){
	colorSel="pvalue"
}

setwd("C:\\ad\\13.KEGG")      #设置工作目录
rt=read.table("interGenes.txt", header=F, sep="\t", check.names=F)     #读取交集基因的列表文件

#提取基因的名称, 将基因名称转换为基因id
genes=unique(as.vector(rt[,1]))
entrezIDs=mget(genes, org.Hs.egSYMBOL2EG, ifnotfound=NA)
entrezIDs=as.character(entrezIDs)
rt=cbind(rt, entrezIDs)
colnames(rt)[1]="gene"
rt=rt[rt[,"entrezIDs"]!="NA",]      #去除基因id为NA的基因
gene=rt$entrezID
#gene=gsub("c\\(\"(\\d+)\".*", "\\1", gene)

#kegg富集分析
kk <- enrichKEGG(gene=gene, organism="hsa", pvalueCutoff=1, qvalueCutoff=1)
kk@result$Description=gsub(" - Homo sapiens \\(human\\)", "", kk@result$Description)
KEGG=as.data.frame(kk)
KEGG$geneID=as.character(sapply(KEGG$geneID,function(x)paste(rt$gene[match(strsplit(x,"/")[[1]],as.character(rt$entrezID))],collapse="/")))
KEGG=KEGG[(KEGG$pvalue<pvalueFilter & KEGG$p.adjust<adjPvalFilter),]
#输出显著富集的结果
write.table(KEGG, file="KEGG.txt", sep="\t", quote=F, row.names = F)

#设置展示通路的数目
showNum=30
if(nrow(KEGG)<showNum){
	showNum=nrow(KEGG)
}

#柱状图
pdf(file="barplot.pdf", width=8.5, height=7)
barplot(kk, drop=TRUE, showCategory=showNum, label_format=100, color=colorSel)
dev.off()

#气泡图
pdf(file="bubble.pdf", width=8.5, height=7)
dotplot(kk, showCategory=showNum, orderBy="GeneRatio", label_format=100, color=colorSel)
dev.off()



###smrML16.MLdata.R

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("limma")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("sva")


#引用包
library(limma)
library(sva)

geneFile="hubGenes.csv"      #核心基因的列表文件
setwd("C:\\ad\\16.MLdata")      #设置工作目录

#获取目录下所有"normalize.txt"结尾的文件
files=dir()
files=grep("normalize.txt$", files, value=T)
geneList=list()

#读取所有表达数据文件中的基因信息，保存到geneList
for(file in files){
    rt=read.table(file, header=T, sep="\t", check.names=F)      #读取输入文件
    geneNames=as.vector(rt[,1])      #提取基因名称
    uniqGene=unique(geneNames)       #基因取unique
    header=unlist(strsplit(file, "\\.|\\-"))
    geneList[[header[1]]]=uniqGene
}

#获取表达数据的交集基因
interGenes=Reduce(intersect, geneList)

#数据合并
allTab=data.frame()
batchType=c()
for(i in 1:length(files)){
    inputFile=files[i]
    header=unlist(strsplit(inputFile, "\\.|\\-"))
    #读取输入文件，并对输入文件进行整理
    rt=read.table(inputFile, header=T, sep="\t", check.names=F)
    rt=as.matrix(rt)
    rownames(rt)=rt[,1]
    exp=rt[,2:ncol(rt)]
    dimnames=list(rownames(exp),colnames(exp))
    data=matrix(as.numeric(as.matrix(exp)),nrow=nrow(exp),dimnames=dimnames)
    rt=avereps(data)
    colnames(rt)=paste0(header[1], "_", colnames(rt))

    #数据合并
    if(i==1){
    	allTab=rt[interGenes,]
    }else{
    	allTab=cbind(allTab, rt[interGenes,])
    }
    batchType=c(batchType, rep(i,ncol(rt)))
}

#提取核心基因的表达量
svaTab=ComBat(allTab, batchType, par.prior=TRUE)
geneRT=read.csv(geneFile, header=T, sep=",", check.names=F)
geneTab=svaTab[intersect(row.names(svaTab), as.vector(geneRT[,"name"])),]
geneTab=t(geneTab)

#提取训练组和测试组的数据
train=grepl("^merge", rownames(geneTab), ignore.case=T)
trainExp=geneTab[train,,drop=F]
testExp=geneTab[!train,,drop=F]
rownames(trainExp)=gsub("merge_", "Train.", rownames(trainExp))
trainType=gsub("(.*)\\_(.*)\\_(.*)", "\\3", rownames(trainExp))
testType=gsub("(.*)\\_(.*)\\_(.*)", "\\3", rownames(testExp))
trainType=ifelse(trainType=="Control", 0, 1)
testType=ifelse(testType=="Control", 0, 1)
trainExp=cbind(trainExp, Type=trainType)
testExp=cbind(testExp, Type=testType)

#输出训练组和测试组的数据
trainOut=rbind(id=colnames(trainExp), trainExp)
write.table(trainOut, file="data.train.txt", sep="\t", quote=F, col.names=F)
testOut=rbind(id=colnames(testExp), testExp)
write.table(testOut, file="data.test.txt", sep="\t", quote=F, col.names=F)


##smrML17.model.R

#install.packages(c("seqinr", "plyr", "openxlsx", "randomForestSRC", "glmnet", "RColorBrewer"))
#install.packages(c("ade4", "plsRcox", "superpc", "gbm", "plsRglm", "BART", "snowfall"))
#install.packages(c("caret", "mboost", "e1071", "BART", "MASS", "pROC", "xgboost"))

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("mixOmics")
#BiocManager::install("survcomp")
#BiocManager::install("ComplexHeatmap")


#引用包
library(openxlsx)
library(seqinr)
library(plyr)
library(randomForestSRC)
library(glmnet)
library(plsRglm)
library(gbm)
library(caret)
library(mboost)
library(e1071)
library(BART)
library(MASS)
library(snowfall)
library(xgboost)
library(ComplexHeatmap)
library(RColorBrewer)
library(pROC)


#设置工作目录
setwd("C:\\ad\\17.ML")
source("refer.ML.R")

#读取训练组的数据文件
Train_data <- read.table("data.train.txt", header = T, sep = "\t", check.names=F, row.names=1, stringsAsFactors=F)
Train_expr=Train_data[,1:(ncol(Train_data)-1),drop=F]
Train_class=Train_data[,ncol(Train_data),drop=F]

#读取测试组的数据文件
Test_data <- read.table("data.test.txt", header=T, sep="\t", check.names=F, row.names=1, stringsAsFactors = F)
Test_expr=Test_data[,1:(ncol(Test_data)-1),drop=F]
Test_class=Test_data[,ncol(Test_data),drop=F]
Test_class$Cohort=gsub("(.*)\\_(.*)\\_(.*)", "\\1", row.names(Test_class))
Test_class=Test_class[,c("Cohort", "Type")]

#获取训练组和测试组的交集基因
comgene <- intersect(colnames(Train_expr), colnames(Test_expr))
Train_expr <- as.matrix(Train_expr[,comgene])
Test_expr <- as.matrix(Test_expr[,comgene])
Train_set = scaleData(data=Train_expr, centerFlags=T, scaleFlags=T) 
names(x = split(as.data.frame(Test_expr), f = Test_class$Cohort))
Test_set = scaleData(data = Test_expr, cohort = Test_class$Cohort, centerFlags = T, scaleFlags = T)

#读取机器学习方法的文件
methodRT <- read.table("refer.methodLists.txt", header=T, sep="\t", check.names=F)
methods=methodRT$Model
methods <- gsub("-| ", "", methods)


#准备机器学习模型的参数
classVar = "Type"         #设置分类的变量名
min.selected.var = 5      #基因数目的阈值
Variable = colnames(Train_set)
preTrain.method =  strsplit(methods, "\\+")
preTrain.method = lapply(preTrain.method, function(x) rev(x)[-1])
preTrain.method = unique(unlist(preTrain.method))


######################根据训练组数据构建机器学习模型######################
#根据模型组合第一种机器学习方法筛选变量
preTrain.var <- list()       #用于保存各算法筛选的变量
set.seed(seed = 123)         #设置种子
for (method in preTrain.method){
  preTrain.var[[method]] = RunML(method = method,          #机器学习方法
                                 Train_set = Train_set,         #训练组的基因表达数据
                                 Train_label = Train_class,    #训练组的分类数据
                                 mode = "Variable",              #选择运行模式(筛选变量)
                                 classVar = classVar)
}
preTrain.var[["simple"]] <- colnames(Train_set)

#根据模型组合第二种机器学习方法构建模型
model <- list()             #初始化模型结果列表
set.seed(seed = 123)       #设置种子
Train_set_bk = Train_set
for (method in methods){
  cat(match(method, methods), ":", method, "\n")
  method_name = method
  method <- strsplit(method, "\\+")[[1]]
  if (length(method) == 1) method <- c("simple", method)
  Variable = preTrain.var[[method[1]]]
  Train_set = Train_set_bk[, Variable]
  Train_label = Train_class
  model[[method_name]] <- RunML(method = method[2],       #机器学习方法
                                Train_set = Train_set,         #训练组的表达数据
                                Train_label = Train_label,    #训练组的分类数据
                                mode = "Model",                 #选择运行模式(构建模型)
                                classVar = classVar)
  
  #如果某种机器学习方法筛选出的变量小于阈值，则该方法结果为空
  if(length(ExtractVar(model[[method_name]])) <= min.selected.var) {
    model[[method_name]] <- NULL
  }
}
Train_set = Train_set_bk; rm(Train_set_bk)
#保存所有机器学习模型的结果
saveRDS(model, "model.MLmodel.rds")

#构建多变量逻辑回归模型
FinalModel <- c("panML", "multiLogistic")[2]
if (FinalModel == "multiLogistic"){
  logisticmodel <- lapply(model, function(fit){    #根据逻辑回归模型计算每个样本的分类概率
    tmp <- glm(formula = Train_class[[classVar]] ~ .,
               family = "binomial", 
               data = as.data.frame(Train_set[, ExtractVar(fit)]))
    tmp$subFeature <- ExtractVar(fit)
    return(tmp)
  })
}
#保存最终以多变量逻辑回归模型
saveRDS(logisticmodel, "model.logisticmodel.rds")


#根据基因表达量计算每个样本的分类得分
model <- readRDS("model.MLmodel.rds")               #使用各个机器学习模型的线性组合函数计算得分
#model <- readRDS("model.logisticmodel.rds")     #使用多变量逻辑回归模型计算得分
methodsValid <- names(model)                          #根据特征基因数目提取有效的模型
#根据基因表达量预测样本的风险得分
RS_list <- list()
for (method in methodsValid){
  RS_list[[method]] <- CalPredictScore(fit = model[[method]], new_data = rbind.data.frame(Train_set,Test_set))
}
riskTab=as.data.frame(t(do.call(rbind, RS_list)))
riskTab=cbind(id=row.names(riskTab), riskTab)
write.table(riskTab, "model.riskMatrix.txt", sep="\t", row.names=F, quote=F)

#根据基因表达量预测样品的分类
Class_list <- list()
for (method in methodsValid){
  Class_list[[method]] <- PredictClass(fit = model[[method]], new_data = rbind.data.frame(Train_set,Test_set))
}
Class_mat <- as.data.frame(t(do.call(rbind, Class_list)))
#Class_mat <- cbind.data.frame(Test_class, Class_mat[rownames(Class_mat),]) # 若要合并测试集本身的样本信息文件可运行此行
classTab=cbind(id=row.names(Class_mat), Class_mat)
write.table(classTab, "model.classMatrix.txt", sep="\t", row.names=F, quote=F)

#提取每种机器学习方法筛选到的变量(模型基因)
fea_list <- list()
for (method in methodsValid) {
  fea_list[[method]] <- ExtractVar(model[[method]])
}
fea_df <- lapply(model, function(fit){
  data.frame(ExtractVar(fit))
})
fea_df <- do.call(rbind, fea_df)
fea_df$algorithm <- gsub("(.+)\\.(.+$)", "\\1", rownames(fea_df))
colnames(fea_df)[1] <- "features"
write.table(fea_df, file="model.genes.txt", sep = "\t", row.names = F, col.names = T, quote = F)

#计算每个模型的AUC值
AUC_list <- list()
for (method in methodsValid){
  AUC_list[[method]] <- RunEval(fit = model[[method]],      #机器学习模型
                                Test_set = Test_set,        #测试组的表达数据
                                Test_label = Test_class,    #测试组的分类数据
                                Train_set = Train_set,      #训练组的表达数据
                                Train_label = Train_class,  #训练组的分类数据
                                Train_name = "Train",        #训练组的标签
                                cohortVar = "Cohort",        #GEO的id
                                classVar = classVar)         #分类变量
}
AUC_mat <- do.call(rbind, AUC_list)
aucTab=cbind(Method=row.names(AUC_mat), AUC_mat)
write.table(aucTab, "model.AUCmatrix.txt", sep="\t", row.names=F, quote=F)


##############################绘制AUC热图##############################
#准备图形的数据
AUC_mat <- read.table("model.AUCmatrix.txt", header=T, sep="\t", check.names=F, row.names=1, stringsAsFactors=F)

#根据AUC的均值对机器学习模型进行排序
avg_AUC <- apply(AUC_mat, 1, mean)
avg_AUC <- sort(avg_AUC, decreasing = T)
AUC_mat <- AUC_mat[names(avg_AUC),]
#获取最优模型(训练组+测试组的AUC均值最大)
fea_sel <- fea_list[[rownames(AUC_mat)[1]]]
avg_AUC <- as.numeric(format(avg_AUC, digits = 3, nsmall = 3))

#设置热图注释的颜色
CohortCol <- c("red", "blue")
if(ncol(AUC_mat)>2){
	CohortCol <- brewer.pal(n = ncol(AUC_mat), name = "Paired")}
names(CohortCol) <- colnames(AUC_mat)

#绘制图形
cellwidth = 1; cellheight = 0.5
hm <- SimpleHeatmap(Cindex_mat = AUC_mat,    #AUC值的矩阵
                    avg_Cindex = avg_AUC,        #AUC均值
                    CohortCol = CohortCol,       #数据集的颜色
                    barCol = "steelblue",        #右侧柱状图的颜色
                    cellwidth = cellwidth, cellheight = cellheight,    #热图每个格子的宽度和高度
                    cluster_columns = F, cluster_rows = F)      #是否对数据进行聚类

#输出热图
pdf(file="model.AUCheatmap.pdf", width=cellwidth * ncol(AUC_mat) + 6, height=cellheight * nrow(AUC_mat) * 0.45)
draw(hm, heatmap_legend_side="right", annotation_legend_side="right")
dev.off()

#输出最优模型的基因
optimalModel=row.names(AUC_mat)[1]
fea_df=fea_df[fea_df$algorithm==optimalModel,]
optimalModelGenes=fea_df[,"features"]
write.table(optimalModelGenes, file="optimalModelGenes.txt", sep="\t", quote=F, row.names=F, col.names=F)


##smrML18.boxplot.R

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("limma")

#install.packages("reshape2")
#install.packages("ggpubr")
#install.packages("PerformanceAnalytics")


#引用包
library(limma)
library(reshape2)
library(ggpubr)
library(PerformanceAnalytics)

expFile="merge.normalize.txt"         #表达数据文件
geneFile="optimalModelGenes.txt"      #基因列表文件
diseaseName="Alzheimer"                #设置图形中展示疾病的名称
setwd("C:\\ad\\18.boxplot")     #设置工作目录

#读取表达数据文件
rt=read.table(expFile, header=T, sep="\t", check.names=F)
rt=as.matrix(rt)
rownames(rt)=rt[,1]
exp=rt[,2:ncol(rt)]
dimnames=list(rownames(exp), colnames(exp))
data=matrix(as.numeric(as.matrix(exp)), nrow=nrow(exp), dimnames=dimnames)
data=avereps(data)

#读取基因列表文件, 提取模型基因的表达量
geneRT=read.table(geneFile, header=F, sep="\t", check.names=F)
sameGene=intersect(as.vector(geneRT[,1]), row.names(data))
data=t(data[sameGene,])

#获取样品的分组信息(对照组和疾病组)
Type=gsub("(.*)\\_(.*)\\_(.*)", "\\3", row.names(data))
treatData=data[Type=="Treat",]
Type=ifelse(Type=="Control", "Control", diseaseName)
Type=factor(Type, levels=c("Control", diseaseName))
rt=cbind(as.data.frame(data), Type)

#将数据转换为箱线图的输入文件
data=melt(rt, id.vars=c("Type"))
colnames(data)=c("Type", "Gene", "Expression")

#绘制箱线图
p=ggboxplot(data, x="Gene", y="Expression", fill = "Type",
	     xlab="",
	     ylab="Gene expression",
	     legend.title="Type",
	     palette = c("#0088FF", "#FF5555"), width=0.75)
p=p+rotate_x_text(45)
p1=p+stat_compare_means(aes(group=Type),
	      method="wilcox.test",
	      symnum.args=list(cutpoints = c(0, 0.001, 0.01, 0.05, 1), symbols = c("***", "**", "*", " ")),
	      label = "p.signif")

#输出图形
pdf(file="boxplot.pdf", width=6, height=4.5)
print(p1)
dev.off()

#绘制相关性图形(PerformanceAnalytics包)
pdf(file="cor.pdf", width=7, height=6.5)
chart.Correlation(treatData, histogram=TRUE, pch=19, method="pearson")
dev.off()

##smrML19.ROC.R

#install.packages("glmnet")
#install.packages("pROC")


#引用包
library(glmnet)
library(pROC)

expFile="merge.normalize.txt"          #表达数据文件
geneFile="optimalModelGenes.txt"      #基因列表文件
setwd("C:\\ad\\19.geneROC")    #设置工作目录

#读取表达数据文件
rt=read.table(expFile, header=T, sep="\t", check.names=F, row.names=1)

#提取样品的分组信息(对照组和疾病组)
y=gsub("(.*)\\_(.*)\\_(.*)", "\\3", colnames(rt))
y=ifelse(y=="Control", 0, 1)

#读取基因列表文件
geneRT=read.table(geneFile, header=F, sep="\t", check.names=F)

#定义图形的颜色
bioCol=rainbow(nrow(geneRT), s=0.9, v=0.9)

#对模型基因进行循环，绘制ROC曲线
aucText=c()
k=0
for(x in as.vector(geneRT[,1])){
	k=k+1
	#绘制ROC曲线
	roc1=roc(y, as.numeric(rt[x,]))     #得到ROC曲线的参数
	if(k==1){
		pdf(file="ROC.genes.pdf", width=5.5, height=5)
		plot(roc1, print.auc=F, col=bioCol[k], legacy.axes=T, main="", lwd=3)
		aucText=c(aucText, paste0(x,", AUC=",sprintf("%.3f",roc1$auc[1])))
	}else{
		plot(roc1, print.auc=F, col=bioCol[k], legacy.axes=T, main="", lwd=3, add=TRUE)
		aucText=c(aucText, paste0(x,", AUC=",sprintf("%.3f",roc1$auc[1])))
	}
}
#绘制图例，得到ROC曲线下的面积
#legend(0.425, 0.625, aucText, lwd=3, bty="n", cex=0.7, col=bioCol[1:(ncol(rt)-1)])
legend('bottomright', aucText, lwd=3, bty="n", cex=0.6, col=bioCol[1:(ncol(rt)-1)])
dev.off()


###smrML20.run.R

install.packages('e1071')

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("preprocessCore")


inputFile="merge.normalize.txt"      #表达数据文件
setwd("C:\\ad\\20.CIBERSORT")      #设置工作目录
source("smrML20.CIBERSORT.R")       #引用包

#免疫细胞浸润分析
outTab=CIBERSORT("ref.txt", inputFile, perm=1000)

#对免疫浸润结果过滤，并且保存免疫细胞浸润结果
outTab=outTab[outTab[,"P-value"]<0.05,]
outTab=as.matrix(outTab[,1:(ncol(outTab)-3)])
outTab=rbind(id=colnames(outTab),outTab)
write.table(outTab, file="CIBERSORT-Results.txt", sep="\t", quote=F, col.names=F)


##smrML21.barplot.R
#install.packages("reshape2")
#install.packages("ggpubr")
#install.packages("corrplot")


#引用包
library(reshape2)
library(ggpubr)
library(corrplot)

inputFile="CIBERSORT-Results.txt"     #免疫细胞浸润分析的结果文件
diseaseName="Rheumatoid arthritis"                 #设置图形中展示疾病的名称
setwd("C:\\ad\\21.barplot")     #设置工作目录

#读取免疫细胞浸润文件
rt=read.table(inputFile, header=T, sep="\t", check.names=F, row.names=1)

#对样品进行分组(对照组和疾病组)
con=grepl("_Control", rownames(rt), ignore.case=T)
treat=grepl("_Treat", rownames(rt), ignore.case=T)
conData=rt[con,]
treatData=rt[treat,]
conNum=nrow(conData)
treatNum=nrow(treatData)
data=t(rbind(conData, treatData))

#绘制柱状图
pdf(file="barplot.pdf", width=13, height=7)
col=rainbow(nrow(data), s=0.7, v=0.7)
par(las=1,mar=c(8,5,4,16),mgp=c(3,0.1,0),cex.axis=1.5)
a1=barplot(data,col=col,xaxt="n",yaxt="n",ylab="Relative Percent",cex.lab=1.5)
a2=axis(2,tick=F,labels=F)
axis(2,a2,paste0(a2*100,"%"))
par(srt=0,xpd=T)
#在图形中标注对照组的样品,用蓝色表示
rect(xleft = a1[1]-0.5, ybottom = -0.01, xright = a1[conNum]+0.5, ytop = -0.08,col="#6699FFFF")
text(a1[conNum]/2,-0.045,"Control",cex=1.8)
#在图形中标注疾病组的样品,用红色表示
rect(xleft = a1[conNum]+0.5, ybottom = -0.01, xright =a1[length(a1)]+0.5, ytop = -0.08,col="#E6550DFF")
text((a1[length(a1)]+a1[conNum])/2,-0.045,diseaseName,cex=1.8)
ytick2 = cumsum(data[,ncol(data)])
ytick1 = c(0,ytick2[-length(ytick2)])
legend(par('usr')[2]*0.98,par('usr')[4],legend=rownames(data),col=col,pch=15,bty="n",cex=1)
dev.off()

##################绘制箱线图##################
#把数据转换成ggplot2输入文件
Type=gsub("(.*)\\_(.*)\\_(.*)", "\\3", colnames(data))
Type=ifelse(Type=="Control", "Control", diseaseName)
Type=factor(Type, levels=c("Control", diseaseName))
data=cbind(as.data.frame(t(data)), Type)
data=melt(data, id.vars=c("Type"))
colnames(data)=c("Type", "Immune", "Expression")
#绘制箱线图
group=levels(factor(data$Type))
bioCol=c("#6699FFFF","#E6550DFF","#0066FF","#FF0000","#6E568C","#7CC767","#223D6C","#D20A13","#FFD121","#088247","#11AA4D")
bioCol=bioCol[1:length(group)]
boxplot=ggboxplot(data, x="Immune", y="Expression", fill="Type",
				  xlab="",
				  ylab="Fraction",
				  legend.title="Type",
				  width=0.8,
				  palette=bioCol)+
				  rotate_x_text(50)+
	stat_compare_means(aes(group=Type),symnum.args=list(cutpoints=c(0, 0.001, 0.01, 0.05, 1), symbols=c("***", "**", "*", "")), label="p.signif")
#输出箱线图
pdf(file="immune.diff.pdf", width=8, height=6)
print(boxplot)
dev.off()

##################绘制免疫细胞相关性的图形##################
treatData=treatData[,apply(treatData,2,sd)>0]
pdf(file="corHeatmap.pdf", width=12, height=12)
corrplot(corr=cor(treatData, method="spearman"),
         method = "color",        #图形的展示形式
         order = "hclust",        #免疫细胞的排序方式
         tl.col="black",          #字体颜色
         number.cex = 0.8,        #相关系数字体大小
         addCoef.col = "black",   #相关系数字体颜色
         col=colorRampPalette(c("#6699FFFF", "white", "#E6550DFF"))(50),    #图形的颜色
         )
dev.off()

##smrML22.immuneCor.R
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("limma")

#install.packages("reshape2")
#install.packages("ggpubr")
#install.packages("ggExtra")


#引用包
library(limma)
library(reshape2)
library(ggpubr)
library(ggExtra)

expFile="merge.normalize.txt"          #表达数据文件
geneFile="optimalModelGenes.txt"      #基因列表文件
immFile="CIBERSORT-Results.txt"       #免疫细胞浸润的结果文件
setwd("C:\\ad\\22.Lollipop")     #设置工作目录

#读取表达数据文件,并对数据进行处理
rt=read.table(expFile, header=T, sep="\t", check.names=F)
rt=as.matrix(rt)
rownames(rt)=rt[,1]
exp=rt[,2:ncol(rt)]
dimnames=list(rownames(exp),colnames(exp))
data=matrix(as.numeric(as.matrix(exp)),nrow=nrow(exp),dimnames=dimnames)
data=avereps(data)

#去除对照组的样品
Type=gsub("(.*)\\_(.*)\\_(.*)", "\\3", colnames(data))
allData=data[,Type=="Treat",drop=F]

#读取基因列表文件
geneRT=read.table(geneFile, header=F, sep="\t", check.names=F)

#对基因进行循环
for(gene in as.vector(geneRT[,1])){
	#提取目标基因的表达量
	data=t(allData[gene,,drop=F])
	data=as.data.frame(data)

	#读取免疫细胞浸润的结果文件
	immune=read.table(immFile, header=T, sep="\t", check.names=F, row.names=1)

	#数据合并
	sameSample=intersect(row.names(immune), row.names(data))
	rt=cbind(immune[sameSample,,drop=F], data[sameSample,,drop=F])

	#对免疫细胞进行循环，进行相关性检验
	outTab=data.frame()
	for(i in colnames(rt)[1:(ncol(rt)-1)]){
		x=as.numeric(rt[,gene])
		y=as.numeric(rt[,i])
		if(sd(y)==0){y[1]=0.00001}
		cor=cor.test(x, y, method="spearman")
		
		outVector=cbind(Gene=gene, Cell=i, cor=cor$estimate, pvalue=cor$p.value)
		outTab=rbind(outTab,outVector)
	}
	#输出免疫细胞相关性的结果
	write.table(outTab,file=paste0("corr.",gene,".result.txt"),sep="\t",row.names=F,quote=F)


	#####################绘制相关性棒棒糖图#####################
	#读取相关性的结果
	data = read.table(paste0("corr.",gene,".result.txt"), header=T, sep="\t", check.names=F)

	#定义圆圈颜色的函数
	p.col = c('gold','pink','orange','LimeGreen','darkgreen')
	fcolor = function(x,p.col){
	  color = ifelse(x>0.8,p.col[1],ifelse(x>0.6,p.col[2],ifelse(x>0.4,p.col[3],
					ifelse(x>0.2,p.col[4], p.col[5])
					)))
	  return(color)
	}

	#定义圆圈大小的函数
	p.cex = seq(2.5, 5.5, length=5)
	fcex = function(x){
	  x=abs(x)
	  cex = ifelse(x<0.1,p.cex[1],ifelse(x<0.2,p.cex[2],ifelse(x<0.3,p.cex[3],
				  ifelse(x<0.4,p.cex[4],p.cex[5]))))
	  return(cex)
	}

	#根据相关性检验的pvalue定义圆圈颜色
	points.color = fcolor(x=data$pvalue,p.col=p.col)
	data$points.color = points.color

	#根据相关系数定义圆圈大小
	points.cex = fcex(x=data$cor)
	data$points.cex = points.cex
	data=data[order(data$cor),]

	########绘制图形########
	pdf(file=paste0("Lollipop.",gene,".pdf"), width=9.5, height=7)      #输出图形
	xlim = ceiling(max(abs(data$cor))*10)/10           #定义x轴范围
	layout(mat=matrix(c(1,1,1,1,1,0,2,0,3,0),nc=2),width=c(8,2.2),heights=c(1,2,1,2,1))
	par(bg="white",las=1,mar=c(5,18,2,4),cex.axis=1.5,cex.lab=2)
	plot(1,type="n",xlim=c(-xlim,xlim),ylim=c(0.5,nrow(data)+0.5),main=gene,xlab="Correlation Coefficient",ylab="",yaxt="n",yaxs="i",axes=F)
	rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4],col="#F5F5F5",border="#F5F5F5")
	grid(ny=nrow(data),col="white",lty=1,lwd=2)
	#在图形中增加线段
	segments(x0=data$cor,y0=1:nrow(data),x1=0,y1=1:nrow(data),lwd=4)
	#在图形中增加圆圈
	points(x=data$cor,y = 1:nrow(data),col = data$points.color,pch=16,cex=data$points.cex)
	#在图形中展示免疫细胞的名称
	text(par('usr')[1],1:nrow(data),data$Cell,adj=1,xpd=T,cex=1.5)
	#展示相关性检验的pvalue
	pvalue.text=ifelse(data$pvalue<0.001,'<0.001',sprintf("%.03f",data$pvalue))
	redcutoff_cor=0
	redcutoff_pvalue=0.05
	text(par('usr')[2],1:nrow(data),pvalue.text,adj=0,xpd=T,col=ifelse(abs(data$cor)>redcutoff_cor & data$pvalue<redcutoff_pvalue,"red","black"),cex=1.5)
	axis(1,tick=F)

	#绘制圆圈大小的图例
	par(mar=c(0,4,3,4))
	plot(1,type="n",axes=F,xlab="",ylab="")
	legend("left",legend=c(0.1,0.2,0.3,0.4,0.5),col="black",pt.cex=p.cex,pch=16,bty="n",cex=2,title="abs(cor)")

	#绘制圆圈颜色的图例
	par(mar=c(0,6,4,6),cex.axis=1.5,cex.main=2)
	barplot(rep(1,5),horiz=T,space=0,border=NA,col=p.col,xaxt="n",yaxt="n",xlab="",ylab="",main="pvalue")
	axis(4,at=0:5,c(1,0.8,0.6,0.4,0.2,0),tick=F)
	dev.off()
}

##smrML25.drugEnrich.R
#install.packages("colorspace")
#install.packages("stringi")
#install.packages("tidytable")
#install.packages("ggplot2")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("org.Hs.eg.db")
#BiocManager::install("DOSE")
#BiocManager::install("clusterProfiler")
#BiocManager::install("enrichplot")


#引用包
library("clusterProfiler")
library("org.Hs.eg.db")
library("enrichplot")
library("tidytable")
library("ggplot2")

pvalueFilter=0.05      #p值过滤条件
adjPvalFilter=0.05     #矫正后p值的过滤条件

drugFile="DSigDB_All_detailed.txt"      #药物和基因的关系文件
hubFile="optimalModelGenes.txt"          #模型基因的文件
setwd("C:\\ad\\25.drugEnrich")      #设置工作目录

#读取模型基因的列表文件
rt=read.table(hubFile, header=F, sep="\t", check.names=F)
#提取基因的名称
genes=unique(as.vector(rt[,1]))

#读取药物和基因的关系文件
drugRT=read.table(drugFile, header=T, sep="\t", check.names=F, quote="", comment.char="")
drugRT=drugRT[,1:2]

#药物富集分析
kk=enricher(genes,
	pvalueCutoff=1, qvalueCutoff=1,
	minGSSize = 10, maxGSSize = 500,
	TERM2GENE=drugRT)

#输出显著富集的结果
DRUG=as.data.frame(kk)
DRUG=DRUG[(DRUG$pvalue<pvalueFilter & DRUG$p.adjust<adjPvalFilter),]
write.table(DRUG[,-c(3,4)], file="DRUG.enrich.xls", sep="\t", quote=F, row.names = F)

#设置展示药物的数目
showNum = ifelse(nrow(DRUG)>30, 30, nrow(DRUG))
showDRUG = DRUG[1:showNum,]
showDRUG$Drug = factor(showDRUG$Description, levels = rev(showDRUG$Description))

#绘制柱状图
bar <- ggplot(data = showDRUG, aes(x = Count, y = Drug, fill = pvalue)) +
	geom_bar(stat = "identity", width = 0.75) +
	scale_fill_distiller(palette = "Spectral", direction = 1) +
	labs(x = "Gene count", y = "", title = "Enriched drug") +
	theme_bw()+ theme(plot.title = element_text(size = 12, hjust = 0.5, face = "bold"),
		 axis.title = element_text(size = 11), axis.text = element_text(size = 10),
          legend.title = element_text(size = 11), legend.text = element_text(size = 10))
#输出图形
pdf(file="barplot.pdf", width=7, height=5.5)
print(bar)
dev.off()

#绘制气泡图
showDRUG$GeneRatio=sapply(showDRUG$GeneRatio, function(x) eval(parse(text = x)))
showDRUG=showDRUG[order(showDRUG$GeneRatio),]
showDRUG$Drug = factor(showDRUG$Drug, levels = showDRUG$Drug)
bubble <- ggplot(data = showDRUG, aes(x = GeneRatio, y = Drug)) +
	geom_point(aes(size = Count, color = pvalue)) + 
	scale_color_distiller(palette = "Spectral", direction = 1) +
	labs(x = "Gene ratio", y = "", title = "Enriched drug", size = "Count") + 
	theme_bw()+ theme(plot.title = element_text(size = 12, hjust = 0.5, face = "bold"),
		axis.title = element_text(size = 11), axis.text = element_text(size = 10),
          legend.title = element_text(size = 11), legend.text = element_text(size = 10))
#输出图形
pdf(file="bubble.pdf", width=7, height=5.5)
print(bubble)
dev.off()

#输出网络关系文件
DRUG=DRUG[,c("ID", "geneID")]
DRUG2=separate_rows(DRUG, geneID, sep="/")
DRUG2=DRUG2 %>% group_by(geneID) %>% slice_head(n=10)     #设置展示药物的数目
networkTab=cbind(DRUG2, "Drug")
colnames(networkTab)=c("Node1", "Node2", "Type")
write.table(file="net.network.txt", networkTab, sep="\t", quote=F, row.names=F)
#输出节点属性文件
drugNode=cbind(unique(networkTab[,1]),"Drug")
colnames(drugNode)=c("Node", "Type")
geneNode=cbind(unique(networkTab[,2]),"Gene")
colnames(geneNode)=c("Node", "Type")
nodeTab=rbind(drugNode, geneNode)
write.table(file="net.node.txt", nodeTab, sep="\t", quote=F, row.names=F)

##smrML26.exposureID.R

refFile="IEU.refer.txt"        #数据库的参考文件
geneFile="optimalModelGenes.txt"     #模型基因的文件
setwd("C:\\ad\\26.exposure")     #设置工作目录

#读取数据库的参考文件
refRT=read.csv(refFile, header=T, sep="\t", check.names=F)

#读取模型基因的文件
geneRT=read.csv(geneFile, header=F, sep="\t", check.names=F)

#提取模型基因的数据
outTab=refRT[refRT$Symbol %in% as.vector(geneRT[,1]),]
write.table(outTab, file="exposureID.txt", sep="\t", row.names=F, quote=F)

##smrML28.coloc.R
#install.packages("dplyr")
#install.packages("data.table")
#install.packages("coloc")

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("VariantAnnotation")

#install.packages("devtools")
#devtools::install_github("mrcieu/ieugwasr",force = TRUE)
#devtools::install_github("mrcieu/gwasglue", force = TRUE)
#devtools::install_github("mrcieu/gwasvcf", force = TRUE)

#library(devtools)
#devtools::install_github("boxiangliu/locuscomparer")


#引用包
library(dplyr)
library(data.table)
library(coloc)
library(VariantAnnotation)
library(gwasglue)
library(locuscomparer)

#输入文件
drugFile="IEU.refer.txt"      #IEU数据库的参考文件
outcomeFile="finngen_R12_G6_ALZHEIMER.gz"       #结局数据文件
finnAnnFile="finngen_R12_manifest.tsv"           #芬兰数据库的注释文件

#设置工作目录
setwd("C:\\ad\\28.coloc")

#读取IEU数据库的参考文件
drugRT=read.table(drugFile, header=T, sep="\t", check.names=F)
row.names(drugRT)=drugRT[,"id"]

#获取目录下所有vcf.gz结尾的文件(基因的数据)
allVcf=list.files(pattern="*.vcf.gz$")

#读取结局数据文件
data0=data.table::fread(outcomeFile, header=T, sep="\t", check.names=F)
finn_info <- fread(finnAnnFile, data.table=F)
trait_row <- finn_info[grepl(outcomeFile, finn_info$path_https),]
data0$ncase.outcome <- trait_row$num_cases
data0$ncontrol.outcome <- trait_row$num_controls
data0$samplesize.outcome <- trait_row$num_cases + trait_row$num_controls
	
#提取结局数据
data1 <- data0 %>% dplyr::select("rsids","#chrom","pos","alt","ref",
	                                 "af_alt","beta","sebeta","pval","samplesize.outcome","ncase.outcome")
colnames(data1) <- c('SNP','chrom',"pos",'effect_allele','other_allele',
	                     "eaf","beta","se","P","samplesize","number_cases")
data2 <- as.data.frame(data1)
data2$varbeta <- data2$se^2
data2$MAF <- ifelse(data2$eaf<0.5,data2$eaf,1-data2$eaf)
data3 <- subset(data2, !duplicated(SNP))
data3$s <- data3$number_cases/data3$samplesize
data3$z = data3$beta/data3$se
GWASdataAll <- data3 %>% na.omit()


#对vcf文件循环(基因的数据)
outTab=data.frame()
for(eqtlFile in allVcf){
	possibleError=tryCatch({
	#获取基因位置信息
	eqtlID=gsub(".vcf.gz", "", eqtlFile)
	geneChr=drugRT[eqtlID, "Chr"]
	geneStart=drugRT[eqtlID, "Start"]
	geneEnd=drugRT[eqtlID, "End"]
	geneName=drugRT[eqtlID, "Symbol"]
	
	#读取基因的数据文件
	vcfRT <- readVcf(eqtlFile)
	data1=gwasvcf_to_TwoSampleMR(vcf=vcfRT, type="exposure")
	
	#挑选暴露数据
	data2 <- data1 %>% dplyr::select("SNP","chr.exposure","pos.exposure","effect_allele.exposure",
	                                 "other_allele.exposure", "eaf.exposure","beta.exposure",
	                                 "se.exposure", "pval.exposure", "samplesize.exposure")
	colnames(data2) <- c("SNP","chrom","Pos","effect_allele","other_allele",
	                     "MAF","beta","se","P","samplesize")
	#整理共定位所需数据
	data3 <- as.data.frame(data2)
	data3$varbeta <- data3$se^2
	data3$z = data3$beta/data3$se
	data3 <- subset(data3, !duplicated(SNP))
	geneData <- data3 %>% filter(chrom==geneChr, Pos>geneStart-100000, Pos<geneEnd+100000) %>% na.omit()
	lead <- geneData %>% dplyr::arrange(P)
	leadPos <- lead$Pos[1]
	QTLdata <-  geneData %>% filter(Pos>leadPos-50000,Pos<leadPos+50000) %>% na.omit()

	#共定位分析	
	sameSNP <- intersect(QTLdata$SNP, GWASdataAll$SNP)
	QTLdata <- QTLdata[QTLdata$SNP %in% sameSNP, ] %>% dplyr::arrange(SNP) %>% na.omit()
	GWASdata <- GWASdataAll[GWASdataAll$SNP %in% sameSNP, ] %>% dplyr::arrange(SNP) %>% na.omit()
	coloc_data <- list(dataset1=list(snp=QTLdata$SNP,beta=QTLdata$beta,varbeta=QTLdata$varbeta,
	                                 N=QTLdata$samplesize,MAF=QTLdata$MAF,z = QTLdata$z,
	                                 pvalues=QTLdata$P,type="quant"), 
	                   dataset2=list(snp=GWASdata$SNP,beta=GWASdata$beta,varbeta=GWASdata$varbeta,
	                                 N=GWASdata$samplesize,MAF=GWASdata$MAF,z = GWASdata$z,
	                                 pvalues=GWASdata$P,type="cc"))
	result <- coloc.abf(dataset1=coloc_data$dataset1, dataset2=coloc_data$dataset2)
	#保存共定位分析的结果
	result$results %>% dplyr::arrange(desc(SNP.PP.H4))
	outTab=rbind(outTab, data.frame(ID=eqtlID,
								   Symbol=geneName,
		                                PP.H0=result$summary[2],
		                                PP.H1=result$summary[3],
		                                PP.H2=result$summary[4],
		                                PP.H3=result$summary[5],
		                                PP.H4=result$summary[6]))
		
	#绘制图形
	GWAS_fn <- GWASdata[,c('SNP','P')] %>% dplyr::rename(rsid = SNP, pval = P)
	eQTL_fn <- QTLdata[,c('SNP','P')] %>% dplyr::rename(rsid = SNP, pval = P)
	pdf(file=paste0(eqtlID, "." , geneName, ".pdf"), width=8, height=6)
	print(locuscompare(in_fn1 = GWAS_fn, 
		                   in_fn2 = eQTL_fn,
		                   snp = NULL,
		                   title1 = 'GWAS', 
		                   title2 = 'eQTL'))
	dev.off()
	},error=function(e) e)
    if(inherits(possibleError, "error")){next}
}
#输出共定位分析的结果
write.csv(outTab, file="coloc.result.csv", row.names=F)


##smrML29.SMRdata.R
#install.packages("dplyr")
#install.packages("tidyr")
#install.packages("data.table")


#引用包
library(dplyr)
library(tidyr)
library(data.table)

inputFile="finngen_R12_G6_ALZHEIMER.gz"      #结局数据文件
finnAnnFile="finngen_R12_manifest.tsv"       #芬兰数据库的注释文件
setwd("C:\\ad\\29.SMRdata")     #设置工作目录

#读取注释文件,获取样品的数目
finn_info <- fread(finnAnnFile, data.table=F)
trait_row <- finn_info[grepl(inputFile, finn_info$path_https),]
sampleSize <- trait_row$num_cases + trait_row$num_controls

#读取结局数据文件
rt=data.table::fread(inputFile, header=T, sep="\t", check.names=F)

#提取输入文件的信息
data=rename(rt,
       SNP=rsids,
       A1=alt,
       A2=ref,
       freq=af_alt,
       b=beta,
       se=sebeta,
       p=pval)
data=select(data, SNP, A1, A2, freq, b, se, p)

#去除重复的SNP
data <-data %>% as_tibble() %>% separate_rows(SNP, sep = ",")
data=data[data$SNP!="",]
outTab=data[!duplicated(data$SNP),]

#在文件中添加样品的数目
outTab$n=sampleSize
#输出结果文件
write.table(outTab, file="outcome.ma", sep="\t", quote=F, row.names=F)


##smrML32.SMRfilter.R

pvalFilter=0.05      #pvalue过滤条件
heidiFilter=0.05     #HEIDI检验pvalue过滤条件
smrFile="SMR.result.symbol.txt"       #SMR分析的结果文件
setwd("C:\\ad\\32.SMRfilter")     #设置工作目录

#读取SMR分析的结果文件
rt=read.table(smrFile, header=T, sep="\t", check.names=F)
data=na.omit(rt)

#对数据进行过滤
outTab=data[((data$p_SMR<pvalFilter) & (data$p_HEIDI>heidiFilter)),]
outTab=outTab[order(outTab$p_SMR),]
write.csv(outTab, file="SMR.filter.csv", row.names=F)






##smrML33.manhattan.R

#install.packages("dplyr")
#install.packages("tidyr")
#install.packages("CMplot")


#引用包
library(dplyr)
library(tidyr)
library(CMplot)

inputFile="SMR.result.symbol.txt"     #SMR分析结果文件
geneFile="SMR.filter.csv"              #基因列表文件
setwd("C:\\ad\\33.manhattan")      #设置工作目录

#读取SMR分析结果文件
rt=read.table(inputFile, header=T, sep="\t", check.names=F)
rt=na.omit(rt)
rt=rt[rt$p_HEIDI>0.05,]

#读取基因列表文件,提取疾病相关的基因
geneRT=read.csv(geneFile, header=T, sep=",", check.names=F)
geneName=as.vector(geneRT[,"Gene"])
showName=geneName
if(length(geneName)>100){showName=showName[1:100]}

#准备绘制曼哈顿图的数据
data=rt[,c("Gene","ProbeChr","Probe_bp","p_SMR")]
colnames(data)=c("Gene","chr","bp","pvalue")

#绘制线性的曼哈顿图
CMplot(data,  plot.type="m",
       LOG10=TRUE, threshold=max(geneRT$p_SMR), chr.den.col=NULL,
       highlight=showName, highlight.text=showName, highlight.cex=1.2, highlight.text.cex=1,
       file="pdf", file.output=TRUE, width=15, height=8.5, verbose=TRUE)

#绘制圈图
CMplot(data,  plot.type="c",
       LOG10=TRUE, threshold=max(geneRT$p_SMR), chr.den.col=NULL,
       highlight=geneName, highlight.text=geneName, highlight.cex=1.2, highlight.text.cex=1,
       file="pdf", file.output=TRUE, width=7, height=7, verbose=TRUE)



##smrML34.venn.R
#install.packages("ggvenn")


#引用包
library(ggvenn)

diffFile="diff.txt"        #差异分析的结果文件
geneFile="optimalModelGenes.txt"      #模型基因的文件
smrFile="SMR.filter.csv"      #SMR分析的结果文件

setwd("C:\\ad\\34.venn")     #设置工作目录
upList=list()        #定义高风险基因的列表
downList=list()      #定义低风险基因的列表

#读取差异分析的结果文件
rt=read.table(diffFile, header=T, sep="\t", check.names=F)
#读取基因列表文件,提取模型基因的差异情况
geneRT=read.table(geneFile, header=F, sep="\t", check.names=F)
rt=rt[rt$id %in% as.vector(geneRT[,1]),]
upRT=rt[rt$logFC>0,]          #提取上调基因的数据
downRT=rt[rt$logFC<0,]        #提取下调基因的数据
upGenes=unique(upRT[,"id"])          #提取上调基因名称
downGenes=unique(downRT[,"id"])     #提取下调基因名称
upList[["logFC>0"]]=upGenes
downList[["logFC<0"]]=downGenes

#读取SMR分析结果文件
rt=read.csv(smrFile, header=T, sep=",", check.names=F)
upRT=rt[rt$b_SMR>0,]          #提取高风险基因的数据
downRT=rt[rt$b_SMR<0,]        #提取低风险基因的数据
upGenes=unique(upRT[,"Gene"])         #提取高风险基因名称
downGenes=unique(downRT[,"Gene"])     #提取低风险基因名称
upList[["SMR_b>0"]]=upGenes
downList[["SMR_b<0"]]=downGenes

#绘制高风险的venn图
pdf(file="up.pdf", width=6, height=6)
ggvenn(upList, show_percentage = T,
	stroke_color = "white", stroke_size = 0.5,
	fill_color = c("#E41A1C","#1E90FF"),
	set_name_color =c("#E41A1C","#1E90FF"),
	set_name_size=6, text_size=4.5)
dev.off()

#绘制低风险的venn图
pdf(file="down.pdf", width=6, height=6)
ggvenn(downList, show_percentage = T,
	stroke_color = "white", stroke_size = 0.5,
	fill_color = c("#E41A1C","#1E90FF"),
	set_name_color =c("#E41A1C","#1E90FF"),
	set_name_size=6, text_size=4.5)
dev.off()

#提取交集基因
upInterGenes=Reduce(intersect, upList)        #高风险的交集基因
upTab=cbind(upInterGenes, "up")
downInterGenes=Reduce(intersect, downList)    #低风险的交集基因
downTab=cbind(downInterGenes, "down")
interTab=data.frame()
if(length(upInterGenes)>0 & length(downInterGenes)>0){
	interTab=rbind(upTab, downTab)
}else if(length(upInterGenes)>0){
	interTab=upTab
}else if(length(downInterGenes)>0){
	interTab=downTab
}
colnames(interTab)=c("Gene", "Type")
row.names(interTab)=interTab[,"Gene"]
row.names(rt)=rt[,"Gene"]
sameGene=intersect(row.names(interTab), row.names(rt))
outTab=cbind(rt[sameGene,"probeID",drop=F], interTab[sameGene,,drop=F])
write.table(file="interGenes.txt", outTab, sep="\t", quote=F, col.names=T, row.names=F)




##smrML36.genePlot.R
#install.packages("magick")
#install.packages("TeachingDemos")


#引用包
library(magick)
library(TeachingDemos)

inputFile="myplot.ENSG00000138448.txt"      #输入文件的名称
setwd("C:\\ad\\36.genePlot")      #设置工作目录
source("plot_SMR.r") 

#读取输入文件
SMRData = ReadSMRData(inputFile)

#绘制染色体位置的图形
pdf(file="SMRLocusPlot.pdf", width=10, height=7)
SMRLocusPlot(data=SMRData, smr_thresh=0.001, heidi_thresh=0.05, plotWindow=1000, max_anno_probe=16)
dev.off()

#绘制单基因的散点图
pdf(file="SMREffectPlot.pdf", width=7, height=5.5)
SMREffectPlot(data=SMRData, trait_name="") 
dev.off()



##


